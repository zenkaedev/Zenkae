// prisma/schema.prisma
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ===== Recruiting =====

model Application {
  id            String   @id @default(cuid())
  guildId       String
  userId        String
  username      String
  nick          String
  className     String
  classId       String?
  status        String   @default("pending") // 'pending' | 'approved' | 'rejected'
  qAnswers      String   @default("[]") // JSON string
  reason        String?
  messageId     String?
  channelId     String?
  attachmentUrl String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Modera√ß√£o
  moderatedById      String?
  moderatedByDisplay String?
  moderatedAt        DateTime?

  @@index([guildId, userId])
  @@index([guildId, status, createdAt])
  @@index([status, createdAt]) // Fix #10: For global status queries
}

model RecruitSettings {
  guildId        String  @id
  panelChannelId String?
  formsChannelId String?
  membersPanelChannelId String? // Canal do painel de membros
  membersPanelMessageId String? // ID da mensagem do painel de membros

  appearanceTitle       String?
  appearanceDescription String?
  appearanceImageUrl    String?
  appearanceThumbUrl    String?
  appearanceAccent      Int? // 0xRRGGBB opcional

  questions             String  @default("[]") // JSON string
  classes               String  @default("[]") // JSON string { id,name,emoji,roleId,color }
  defaultApprovedRoleId String?

  dmAcceptedTemplate String   @default("Parab√©ns! Voc√™ foi aprovado üéâ")
  dmRejectedTemplate String   @default("Obrigado por se inscrever. Infelizmente sua candidatura foi recusada. Motivo: {reason}")
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

model MessageCounter {
  id        String   @id @default(cuid())
  guildId   String
  userId    String
  count     Int      @default(0)
  updatedAt DateTime @updatedAt

  @@unique([guildId, userId])
}

model RecruitPanel {
  guildId   String   @id
  channelId String
  messageId String
  updatedAt DateTime @updatedAt
}

// ===== Eventos (Unificado: RSVP + ZK + Recorr√™ncia) =====

model Event {
  id          String   @id @default(cuid())
  guildId     String
  title       String
  description String?  @db.Text
  startsAt    DateTime
  status      String   @default("scheduled") // 'scheduled' | 'cancelled' | 'completed'
  channelId   String
  messageId   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Novos campos (Unifica√ß√£o ZK + Features)
  imageUrl              String?
  voiceChannelId        String?
  zkReward              Int     @default(0)
  announcementChannelId String?
  recurrence            String? // 'WEEKLY' ou null
  recurrenceDay         Int?    // 0=Domingo, 1=Segunda...
  dmMessage             String? // Mensagem personalizada enviada 1h antes

  rsvps     EventRsvp[]
  reminders EventReminder[]

  @@index([guildId, startsAt])
  @@index([status, startsAt]) // Fix #10: For scheduler queries
  @@index([guildId, status, startsAt]) // Fix #10: For dashboard queries
}

model EventRsvp {
  id        String   @id @default(cuid())
  eventId   String
  guildId   String
  userId    String
  choice    String // 'yes' | 'maybe' | 'no'
  updatedAt DateTime @updatedAt

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([guildId, eventId, choice])
}

model EventReminder {
  id      String   @id @default(cuid())
  eventId String
  kind    String // '24h' | '1h' | '15m'
  sentAt  DateTime @default(now())

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, kind])
}

// ===== Atividade semanal (check-in) =====

model MemberActivity {
  id          String   @id @default(cuid())
  guildId     String
  userId      String
  lastCheckAt DateTime @default(now())

  @@unique([guildId, userId])
}

model ActivityPanel {
  guildId   String   @id
  channelId String
  messageId String
  weekStart DateTime
  updatedAt DateTime @updatedAt
}

// ===== Enquetes (Polls) =====

model Poll {
  id          String    @id @default(cuid())
  guildId     String
  channelId   String
  messageId   String?
  question    String
  optionsJson String // JSON string: string[] (ordem = √≠ndices)
  multi       Boolean   @default(false)
  endsAt      DateTime?
  createdById String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  votes PollVote[]

  @@index([guildId, createdAt])
  @@index([guildId, endsAt])
}

model VoiceActivity {
  guildId      String
  userId       String
  totalSeconds Int      @default(0)
  updatedAt    DateTime @updatedAt

  @@id([guildId, userId])
  @@index([guildId, totalSeconds])
}

model VoiceActivityWeek {
  guildId      String
  userId       String
  weekStart    DateTime
  totalSeconds Int      @default(0)
  updatedAt    DateTime @updatedAt

  @@id([guildId, userId, weekStart])
  @@index([guildId, weekStart, totalSeconds])
}

model PollVote {
  id        String   @id @default(cuid())
  pollId    String
  userId    String
  optionIdx Int
  createdAt DateTime @default(now())

  poll Poll @relation(fields: [pollId], references: [id], onDelete: Cascade)

  @@unique([pollId, userId, optionIdx]) // toggle por op√ß√£o no multi
  @@index([pollId, optionIdx])
}

// ===== XP & Leveling System =====

model UserLevel {
  id            String   @id @default(cuid())
  guildId       String
  userId        String
  xpTotal       Int      @default(0)
  level         Int      @default(1)
  lastMessageAt DateTime @default(now()) // Para cooldown de 60s

  @@unique([guildId, userId])
  @@index([guildId, xpTotal])
  @@index([guildId, level])
}

model UserZK {
  guildId String
  userId  String
  balance Int      @default(0)

  @@id([guildId, userId])
}

model ZKTransaction {
  id        String   @id @default(cuid())
  guildId   String
  userId    String
  amount    Int
  reason    String
  balanceBefore Int
  balanceAfter  Int
  createdAt DateTime @default(now())

  @@index([guildId, userId])
}

model RankSettings {
  guildId             String    @id
  weeklyRoleId        String?
  monthlyRoleId       String?
  lastWeeklyRotation  DateTime?
  lastMonthlyRotation DateTime?
  updatedAt           DateTime  @updatedAt
}

model EconomySettings {
  guildId           String   @id
  currencyName      String   @default("Coins")
  currencyEmoji     String   @default("ü™ô")
  eventDefaultReward Int      @default(10)
  updatedAt         DateTime @updatedAt
}

model UserXPPeriod {
  id         String   @id @default(cuid())
  guildId    String
  userId     String
  periodType String // 'WEEKLY', 'MONTHLY'
  startDate  DateTime // The "key" for the period (Monday 00:00 BRT)
  xp         Int      @default(0)
  updatedAt  DateTime @updatedAt

  @@unique([guildId, userId, periodType, startDate])
  @@index([guildId, periodType, startDate, xp]) // For ranking queries
}

// Tabela ZKEvent removida em favor da Event unificada

model AuctionItem {
  id            String       @id @default(cuid())
  guildId       String
  name          String
  description   String       @db.Text
  imageUrl      String
  startingPrice Int          @default(0)
  minIncrement  Int          @default(10)
  active        Boolean      @default(true)
  createdAt     DateTime     @default(now())
  bids          AuctionBid[]

  @@index([guildId])
}

model AuctionBid {
  id          String      @id @default(cuid())
  guildId     String
  itemId      String
  userId      String
  amount      Int
  createdAt   DateTime    @default(now())
  item        AuctionItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@index([itemId, amount])
}

// ===== Suggestions System =====

model SuggestionSettings {
  guildId              String   @id
  panelChannelId       String?  // Canal do painel p√∫blico
  panelMessageId       String?  // ID da mensagem do painel
  suggestionsChannelId String?  // Canal onde sugest√µes s√£o enviadas
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

model Suggestion {
  id          String   @id @default(cuid())
  guildId     String
  userId      String   // Autor
  userDisplay String   // Display name do autor
  title       String   @db.VarChar(100)
  description String   @db.Text
  channelId   String   // Canal onde foi postada
  messageId   String   // ID da mensagem
  threadId    String?  // ID da thread de discuss√£o
  createdAt   DateTime @default(now())

  votes SuggestionVote[]

  @@index([guildId, createdAt])
  @@index([messageId])
}

model SuggestionVote {
  id           String     @id @default(cuid())
  suggestionId String
  userId       String
  voteType     String     // 'agree' | 'disagree'
  createdAt    DateTime   @default(now())

  suggestion Suggestion @relation(fields: [suggestionId], references: [id], onDelete: Cascade)

  @@unique([suggestionId, userId]) // Um voto por usu√°rio
  @@index([suggestionId, voteType])
}

// ===== Matchmaking / LFG System =====

model Party {
  id          String   @id @default(cuid())
  guildId     String
  channelId   String
  messageId   String   @unique
  leaderId    String   // Discord user ID
  title       String
  datetime    String   // Formato livre: "Sexta-feira, 20:00"
  description String   @db.Text
  slotsJson   String   @db.Text // JSON: { "Tank": { max: 1, members: [...] }, ... }
  status      String   @default("open") // 'open' | 'full' | 'cancelled'
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members PartyMember[]

  @@index([guildId, status])
  @@index([messageId])
}

model PartyMember {
  id        String   @id @default(cuid())
  partyId   String
  userId    String   // Discord user ID
  role      String   // 'Tank', 'Healer', 'DPS', etc
  joinedAt  DateTime @default(now())

  party Party @relation(fields: [partyId], references: [id], onDelete: Cascade)

  @@unique([partyId, userId]) // Um usu√°rio s√≥ pode estar uma vez na mesma party
  @@index([partyId, role])
}

model MatchmakingSettings {
  guildId        String   @id
  totemChannelId String?  // Canal onde o totem est√° publicado
  totemMessageId String?  // ID da mensagem do totem
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}
